#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division
__author__ = "Johan Hake (hake.dev@gmail.com)"
__date__ = "2013-03-13 -- 2014-01-29"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU LGPL Version 3.0 or later"

from modelparameters.codegeneration import latex
from scipy.integrate import odeint
import pylab
import numpy as np
import instant
from gotran.model.loadmodel2 import load_ode
from gotran.codegeneration.compilemodule2 import compile_module
from gotran.common.options import parameters
from gotran.common import error

def main(filename, params):

    # Copy of default parameters
    generation = parameters.generation.copy()

    # Set body parameters
    generation.code.body.representation = params.code.body_repr
    generation.code.body.use_cse = params.code.use_cse
    generation.code.body.optimize_exprs = params.code.optimize_exprs

    # Set what code we are going to generate and not
    for what_not in ["componentwise_rhs_evaluation",
                     "forward_backward_subst",
                     "linearized_rhs_evaluation",
                     "lu_factorization"]:
        generation.functions[what_not].generate = False

    for what in ["rhs", "monitored"]:
        generation.functions[what].generate = True

    if params.use_jacobian:
        generation.functions.jacobian.generate = params.use_jacobian
    
    # Compile executeable code from gotran ode
    ode = load_ode(filename)

    # Check for DAE
    if ode.is_dae:
        error("Can only integrate pure ODEs. {0} includes algebraic states "\
              "and is hence a DAE.")
    
    # Get monitored and plot states
    plot_states = params.plot
    state_names = [state.name for state in ode.full_states]
    monitored_plot = [plot_states.pop(plot_states.index(name)) \
                      for name in plot_states[:] if name not in state_names]
    
    monitored = [expr.name for expr in ode.intermediates + ode.state_expressions]

    module = compile_module(ode, params.code.language, monitored, generation)

    parameter_values = params.parameters
    init_conditions = params.init_conditions

    if len(parameter_values) == 1 and parameter_values[0] == "":
        parameter_values = []

    if len(init_conditions) == 1 and init_conditions[0] == "":
        init_conditions = []

    if len(parameter_values) % 2 != 0:
        error("Expected an even number of values for 'parameters'")

    if len(init_conditions) % 2 != 0:
        error("Expected an even number of values for 'initial_conditions'")

    user_params = dict()
    for param_name, param_value in [(parameter_values[i*2], parameter_values[i*2+1]) \
                                    for i in range(int(len(parameter_values)/2))]:
        
        user_params[param_name] = float(param_value)

    user_ic = dict()
    for state_name, state_value in [(init_conditions[i*2], init_conditions[i*2+1]) \
                                    for i in range(int(len(init_conditions)/2))]:
        
        user_ic[state_name] = float(state_value)

    # Use scipy to integrate model
    t0 = 0.
    t1 = params.tstop
    dt = params.dt

    rhs = module.rhs
    y0 = module.init_state_values(**user_ic)
    model_params = module.init_parameter_values(**user_params)

    tsteps = np.linspace(t0, t1, t1/dt+1)
    if params.use_jacobian:
        results = odeint(rhs, y0, tsteps, Dfun=module.compute_jacobian, \
                         args=(model_params,))
    else:
        results = odeint(rhs, y0, tsteps, args=(model_params,))

    # Plot results
    if not (plot_states or monitored):
        return
    
    plot_inds = [module.state_indices(state) for state in plot_states]
    #plot_results = [[] for state in plot_states]
    
    monitored_values = [[] for monitor in monitored_plot]
    monitor_inds = np.array([monitored.index(monitor) \
                             for monitor in monitored_plot], dtype=int)
    monitored_get_values = np.zeros(len(monitored), dtype=np.float_)

    # Allocate memory
    plot_values = np.zeros((len(plot_states)+len(monitored_plot), len(results)))

    for ind, (time, res) in enumerate(zip(tsteps, results)):
        
        if plot_states:
            plot_values[:len(plot_states), ind] = res[plot_inds]
        if monitored_plot:
            module.monitor(res, time, model_params, monitored_get_values)
            plot_values[len(plot_states):, ind] = monitored_get_values[\
                monitor_inds]
        
    # Plot data
    pylab.plot(tsteps, np.transpose(plot_values))
    pylab.legend(["$\\mathrm{{{0}}}$".format(latex(value))
                  for value in plot_states + monitored_plot])
    pylab.xlabel("time")
    pylab.title(ode.name.replace("_", "\\_"))
    pylab.show()

if __name__ == "__main__":
    import sys, os
    from modelparameters.parameterdict import *

    body_params=parameters.generation.code.body.copy()
    
    code_params = ParameterDict(
        language = OptionParam("Python", ["Python", "C"]),
        body_repr = dict.__getitem__(body_params, "representation"),
        use_cse = dict.__getitem__(body_params, "use_cse"),
        optimize_exprs = dict.__getitem__(body_params, "optimize_exprs"),
        )
    
    params = ParameterDict(\
        parameters = Param([""], description="Set parameter of model"),
        init_conditions = Param([""], description="Set initial condition of model"),
        tstop = ScalarParam(100., gt=0, description="Time for stopping simulation"),\
        dt = ScalarParam(0.1, gt=0, description="Timestep for plotting."),\
        plot = Param(["V"], description="States or monitored to plot."),\
        use_jacobian = Param(True, description="Use analytic jacobian when integrating."),\
        code = code_params)
    
    params.parse_args(usage="usage: %prog FILE [options]")
    
    if len(sys.argv) < 2:
        error("Expected a single gotran file argument.")

    if not os.path.isfile(sys.argv[1]):
        error("Expected the argument to be a file.", exception=IOError)
	 
    file_name = sys.argv[1]
    main(file_name, params)
