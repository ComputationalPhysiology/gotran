#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import division
__author__ = "Johan Hake (hake.dev@gmail.com)"
__date__ = "2013-03-13 -- 2014-01-21"
__copyright__ = "Copyright (C) 2013 " + __author__
__license__  = "GNU LGPL Version 3.0 or later"

from modelparameters.codegeneration import latex
from scipy.integrate import odeint
import pylab
import numpy as np
import instant
from gotran.model.loadmodel2 import load_ode
from gotran.codegeneration.compilemodule2 import compile_module
from gotran.common.options import parameters

def main(filename, params):

    # Copy of default parameters
    generation = parameters.generation.copy()

    # Set body parameters
    generation.code.body.representation = params.code.body_repr
    generation.code.body.use_cse = params.code.use_cse
    generation.code.body.optimize_exprs = params.code.optimize_exprs

    # Set what code we are going to generate and not
    for what_not in ["componentwise_rhs_evaluation",
                     "forward_backward_subst",
                     "linearized_rhs_evaluation",
                     "lu_factorization"]:
        generation.functions[what_not].generate = False

    for what in ["rhs", "monitored"]:
        generation.functions[what].generate = True

    if params.use_jacobian:
        generation.functions.jacobian.generate = params.use_jacobian
    
    # Compile executeable code from gotran ode
    ode = load_ode(filename)
    
    # Get monitored and plot states
    plot_states = params.plot
    state_names = [state.name for state in ode.full_states]
    monitored = [plot_states.pop(plot_states.index(name)) \
                 for name in plot_states[:] if name not in state_names]

    module = compile_module(ode, params.code.language, monitored, generation)

    parameter_values = params.parameters
    init_conditions = params.init_conditions

    if len(parameter_values) == 1 and parameter_values[0] == "":
        parameter_values = []

    if len(init_conditions) == 1 and init_conditions[0] == "":
        init_conditions = []

    if len(parameter_values) % 2 != 0:
        raise RuntimeError("Expected an even number of values for 'parameters'")

    if len(init_conditions) % 2 != 0:
        raise RuntimeError("Expected an even number of values for 'initial_conditions'")

    user_params = dict()
    for param_name, param_value in [(parameter_values[i*2], parameter_values[i*2+1]) \
                                    for i in range(int(len(parameter_values)/2))]:
        
        user_params[param_name] = float(param_value)

    user_ic = dict()
    for state_name, state_value in [(init_conditions[i*2], init_conditions[i*2+1]) \
                                    for i in range(int(len(init_conditions)/2))]:
        
        user_ic[state_name] = float(state_value)

    # Use scipy to integrate model
    t0 = 0.
    t1 = params.tstop
    dt = params.dt

    rhs = module.rhs
    y0 = module.init_state_values(**user_ic)
    model_params = module.init_parameter_values(**user_params)

    tsteps = np.linspace(t0, t1, t1/dt+1)
    if params.use_jacobian:
        results = odeint(rhs, y0, tsteps, Dfun=module.compute_jacobian, \
                         args=(model_params,))
    else:
        results = odeint(rhs, y0, tsteps, args=(model_params,))

    # Plot results
    if not (plot_states or monitored):
        return
    
    plot_inds = [module.state_indices(state) for state in plot_states]
    plot_results = [[] for state in plot_states]
    
    monitored_values = [[] for monitor in monitored]
    
    for time, res in zip(tsteps, results):
        for ind, plot_ind in enumerate(plot_inds):
            plot_results[ind].append(res[plot_ind])

        if monitored:
            for ind, value in enumerate(module.monitor(res, time, model_params)):
                monitored_values[ind].append(value)

    # Build plot arguments
    plot_args = []
    for plot_result in plot_results:
        plot_args.append(tsteps)
        plot_args.append(np.array(plot_result))

    for plot_result in monitored_values:
        plot_args.append(tsteps)
        plot_args.append(np.array(plot_result))

    pylab.plot(*plot_args)
    pylab.legend(["$\\mathrm{{{0}}}$".format(latex(value))
                  for value in plot_states + monitored])
    pylab.xlabel("time")
    pylab.title(ode.name.replace("_", "\\_"))
    pylab.show()

if __name__ == "__main__":
    import sys, os
    from modelparameters.parameterdict import *

    body_params=parameters.generation.code.body.copy()
    
    code_params = ParameterDict(
        language = OptionParam("Python", ["Python", "C"]),
        body_repr = dict.__getitem__(body_params, "representation"),
        use_cse = dict.__getitem__(body_params, "use_cse"),
        optimize_exprs = dict.__getitem__(body_params, "optimize_exprs"),
        )
    
    params = ParameterDict(\
        parameters = Param([""], description="Set parameter of model"),
        init_conditions = Param([""], description="Set initial condition of model"),
        tstop = ScalarParam(100., gt=0, description="Time for stopping simulation"),\
        dt = ScalarParam(0.1, gt=0, description="Timestep for plotting."),\
        plot = Param(["V"], description="States or monitored to plot."),\
        use_jacobian = Param(True, description="Use analytic jacobian when integrating."),\
        code = code_params)
    
    params.parse_args(usage="usage: %prog FILE [options]")
    
    if len(sys.argv) < 2:
        raise RuntimeError("Expected a single gotran file argument")

    if not os.path.isfile(sys.argv[1]):
        raise IOError("Expected the argument to be a file")
	 
    file_name = sys.argv[1]
    main(file_name, params)
